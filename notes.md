# Системное программирование
[679e84225040133e8429ed75](https://e-learn.petrocollege.ru/course/view.php?id=6815)

- [Общее](#общее)
  - [Образ ОС](#образ-ос)
- [Исполняемые файлы](#исполняемые-файлы)
  - [Исполняемые файлы (bash)](#исполняемые-файлы-bash)
  - [Как устроены bash-скрипты](#как-устроены-bash-скрипты)
  - [Установка разрешений для файла сценария](#установка-разрешений-для-файла-сценария)
  - [Использование переменных](#использование-переменных)
  - [Зарезервированные переменные](#зарезервированные-переменные)
  - [Пользовательские переменные](#пользовательские-переменные)
  - [Математические операции](#математические-операции)
  - [Управляющая конструкция `if-then`](#управляющая-конструкция-if-then)
  - [Сравнение чисел](#сравнение-чисел)
    - [Задание 1](#задание-1)
  - [Сравнение строк](#сравнение-строк)
  - [Циклы `for`](#циклы-for)
  - [Перебор простых значений](#перебор-простых-значений)
  - [Перебор сложных](#перебор-сложных)
  - [Инициализация цикла списком, полученным из результатов работы команды](#инициализация-цикла-списком-полученным-из-результатов-работы-команды)
  - [Разделители полей](#разделители-полей)
  - [Циклы `for` в стиле C](#циклы-for-в-стиле-c)
  - [Цикл `while`](#цикл-while)
- [Чтение параметров командной строки](#чтение-параметров-командной-строки)
  - [Чтение параметров](#чтение-параметров)
  - [Проверка параметров](#проверка-параметров)
  - [Подсчёт параметров](#подсчёт-параметров)
  - [Захват всех параметров командной строки](#захват-всех-параметров-командной-строки)
  - [Команда shift](#команда-shift)
  - [Ключи командной строки](#ключи-командной-строки)
  - [Как различать ключи и параметры](#как-различать-ключи-и-параметры)
  - [Обработка ключей со значениями](#обработка-ключей-со-значениями)
  - [Использование стандартных ключей](#использование-стандартных-ключей)
  - [Получение данных от пользователя](#получение-данных-от-пользователя)
  - [Ввод паролей](#ввод-паролей)
  - [Чтение данных из файла](#чтение-данных-из-файла)
  - [Итоги](#итоги)
- [Функции](#функции)
  - [Использование команды return](#использование-команды-return)
  - [Аргументы функций](#аргументы-функций)
  - [Глобальные переменные](#глобальные-переменные)
  - [Локальные переменные](#локальные-переменные)
  - [Bash-скрипты: Регулярные выражения](#bash-скрипты-регулярные-выражения)
- [Самостоятельные работы](#самостоятельные-работы)

## Общее
[679e897e5040133e8429ed76](https://e-learn.petrocollege.ru/course/view.php?id=6815#section-0)

Все работы выполняются в ОС Ubuntu 22.04.03 lts Server.

### Образ ОС
https://e-learn.petrocollege.ru/mod/resource/view.php?id=313200

- log: user
- pass: 1234

## Исполняемые файлы
[679e8f315040133e8429ed77](https://e-learn.petrocollege.ru/course/view.php?id=6815#section-1)

### Исполняемые файлы (bash)
https://e-learn.petrocollege.ru/mod/resource/view.php?id=313188

Сценарии командной строки — это наборы тех же самых команд, которые можно вводить с клавиатуры, собранные в файлы и объединённые некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд.

Сценарии — это мощный способ автоматизации часто выполняемых действий.

### Как устроены bash-скрипты
1. Любой bash-скрипт должен начинаться со строки:

    ```sh
    #!/bin/bash
    ```

    в этой строке после `#!` указывается путь к bash-интерпретатору, поэтому если он у вас установлен в другом месте (где, вы можете узнать набрав `whereis bash`) поменяйте её на ваш путь.

2. Коментарии начинаются с символа `#` (кроме первой строки).

3. В bash переменные не имеют типа.

Создайте пустой файл с использованием команды `touch`.
```sh
#!/bin/bash
```

В других строках этого файла символ решётки используется для обозначения комментариев, которые оболочка не обрабатывает. 
```sh
#!/bin/bash
# This is a comment
pwd
whoami
```

[Script 01](./src/01-executables/01-intro.sh)
### Установка разрешений для файла сценария

*Попытка запуска файла сценария с неправильно настроенными разрешениями*:
```
$ ./myscript
bash: ./myscript: Permission denied
$
```

*Запуск файла с разрешениями:*
```
$ chmod +x ./myscript
$ ./myscript
/home/likegeeks/Desktop
likegeeks
$
```

```sh
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```

*Output*:
```
$ ./myscript
The current directory is:
/home/likegeeks/Desktop
The user logged in is:
likegeeks
```

[Scrip6 02](./src/01-executables/02-permit.sh)

### Использование переменных
Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.

Существуют два типа переменных, которые можно использовать в bash-скриптах:
- переменные среды;
- пользовательские переменные.

```sh
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
```

*Output*:
```sh
$ ./myscript
Home for the current user is: /home/likegeeks
```

[Script 03](./src/01-executables/03-vars.sh)

### Зарезервированные переменные
Встроенные переменные BASH:
- `$DIRSTACK` — содержимое вершины стека каталогов;

- `$EDITOR` — текстовый редактор по умолчанию;

- `$EUID` — эффективный UID, идентификационный номер пользователя, права которого были получены, возможно с помощью команды `su`. Если вы использовали программу `su` для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя.

  > Значение переменной `$EUID` необязательно должно совпадать с содержимым переменной `$UID`!

- `$UID` - содержит реальный идентификатор, который устанавливается только при логине;

- `$FUNCNAME` — имя текущей функции в скрипте;

- `$GROUPS` — массив групп к которым принадлежит текущий пользователь;

- `$HOME` — домашний каталог пользователя;

- `$HOSTNAME` — ваш hostname;

- `$HOSTTYPE` — архитектура машины;

- `$LC_CTYPE` — внутренняя переменная, которая определяет кодировку символов;

- `$OLDPWD` — прежний рабочий каталог;

- `$OSTYPE` — тип ОС;

- `$PATH` — путь поиска программ;

- `$PPID` — идентификатор родительского процесса;

- `$SECONDS` — время работы скрипта (в сек.);

- `$#` — общее количество параметров, переданных скрипту;

- `$*` — все аргументы переданные скрипту (выводятся в строку);

- `$@` — тоже самое, что и предыдущий, но параметры выводятся в столбик;

- `$!` — PID последнего запущенного в фоне процесса;

- `$$` — PID самого скрипта.

### Пользовательские переменные
Bash-скрипты позволяют задавать и использовать в сценарии собственные переменные. Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария.

```sh
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

*Output*:
```
$ ./myscript
Adam is a good boy, he is in grade 5
$
```

[Script 04](./src/01-executables/04-user_vars.sh)

### Математические операции
Для выполнения математических операций в файле скрипта можно использовать конструкцию вида `$((a+b))`:
```sh
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
```

*Output*:
```
$ ./myscript
10
20
$
```

[Script 05](./src/01-executables/05-math.sh)

### Управляющая конструкция `if-then`
В наиболее простом виде она выглядит так:
```sh
if команда
then
  команды
fi
```

вот рабочий пример:
```sh
#!/bin/bash
if pwd
then
echo "It works"
fi
```

[Script 06](./src/01-executables/06-if-then.sh)

Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией `if-then-else`. Вот как она устроена:
```sh
if команда
then
  команды
else
  команды
fi
```

[Script 07](./src/01-executables/07-if-then-else.sh)

### Сравнение чисел
Логические операторы:
```sh
-z          # строка пуста
-n          # строка не пуста
!=          # строки не равны
-eq         # равно
-ne         # неравно
-lt, ( < )  # меньше
-le, ( <= ) # меньше или равно
-gt, ( > )  # больше
-ge, ( >= ) # больше или равно
!           # отрицание логического выражения
-a, ( && )  # логическое "И"
-o, ( || )  # логическое "ИЛИ"
```

#### Задание 1
Ввести числовую переменную.

Если переменная больше 5 то вывести на экран «The test value <переменная> is greater than 5» иначе «The test value <переменная> is not greater than 5».

```
$ ./myscript
The test value  is greater than 5
$
```

[Solution/Script 08](./src/01-executables/08-task01.sh)

### Сравнение строк
- `str1 = str2`: Проверяет строки на равенство, возвращает истину, если строки идентичны;
- `str1 != str2`: Возвращает истину, если строки не идентичны;
- `str1 < str2`: Возвращает истину, если `str1` меньше, чем `str2`;
- `str1 > str2`: Возвращает истину, если `str1` больше, чем `str2`;
- `-n str1`: Возвращает истину, если длина `str1` больше нуля;
- `-z str1`: Возвращает истину, если длина `str1` равна нулю.

```sh
#!/bin/bash
user ="likegeeks"
if [ $user = $USER ]
then
echo "The user $user is the current logged in user"
fi
```

*Output*:
```
The user likegeeks is the current logged in user
```

[Script 09](./src/01-executables/09-strings.sh)

### Циклы `for`
Базовая структура таких циклов:
```sh
for var in list
do
	команды
done
```

В каждой итерации цикла в переменную `var` будет записываться следующее значение из списка `list`.

### Перебор простых значений
Перебор списка простых значений
```sh
#!/bin/bash
for var in first second third fourth fifth
do
	echo The  $var item
done
```

*Output*:
```
$ ./myscript
The first item
The second item
The third item
The fourth item
The fifth item
$
```

[Script 10](./src/01-executables/10-for_words.sh)

### Перебор сложных
```sh
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
do
	echo "This is: $var"
done
```

*Output*:
```
$ ./myscript
This is: first
This is: the second
This is: the third
This is: I'll do it
$
```

[Script 11](./src/01-executables/11-for_strings.sh)

### Инициализация цикла списком, полученным из результатов работы команды
```sh
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
```

*Output*:
```sh
$ ./myscript
 hello
 this
 is
 test
$
```

[myfile](./src/01-executables/myfile)

[Script 12](./src/01-executables/12-for_from_file.sh)

### Разделители полей
*[IFS]: Internal Field Separator
Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется IFS (Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:
- Пробел
- Знак табуляции
- Знак перевода строки

```
IFS=$'\n'
```

### Циклы `for` в стиле C
```c
for (i = 0; i < 10; i++)
{
	printf("number is %d\n", i);
}
```

Схема цикла выглядит так:
```c
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
```

На bash это можно записать так:
```sh
for (( a = 1; a < 10; a++ ))
```

Пример:
```sh
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
```

*Output*:
```sh
$ ./myscript
number 1 is 1
number 1 is 2
number 1 is 3
number 1 is 4
number 1 is 5
number 1 is 6
number 1 is 7
number 1 is 8
number 1 is 9
number 1 is 10
```

### Цикл `while`
Вот схема организации циклов `while`:
```sh
while команда проверки условия
do
  другие команды
done
```

ПРИМЕР:
```sh
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
```

## Чтение параметров командной строки
[679f375d5040133e8429ed7a](https://e-learn.petrocollege.ru/course/view.php?id=6815#section-2)

https://e-learn.petrocollege.ru/mod/resource/view.php?id=313190

Наиболее распространённый способ передачи данных сценариям заключается в использовании параметров командной строки. Вызвав сценарий с параметрами, мы передаём ему некую информацию, с которой он может работать. Выглядит это так:
```
$ ./myscript 10 20
```

В данном примере сценарию передано два параметра — «10» и «20». Всё это хорошо, но как прочесть данные в скрипте?

### Чтение параметров
[67a331485040133e8429ede5](https://e-learn.petrocollege.ru/mod/resource/view.php?id=313189)

```
$ ./myscript 10 20
```

Оболочка bash назначает специальным переменным, называемым **позиционными параметрами**, введённые при вызове скрипта параметры командной строки:
- `$0` — имя скрипта;
- `$1` — первый параметр;
- `$2` — второй параметр — и так далее, вплоть до переменной `$9`, в которую попадает девятый параметр.

Вот как можно использовать параметры командной строки в скрипте с помощью этих переменных:

```sh
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
```

Запустим сценарий с параметрами:
```
./myscript 5 10 15
```

Вот что он выведет в консоль.

*Вывод параметров, с которыми запущен скрипт*
```
$ ./myscript 5 10 15
./myscript
5
10
15
```

Обратите внимание на то, что параметры командной строки разделяются пробелами.

Взглянем на ещё один пример использования параметров. Тут мы найдём сумму чисел, переданных сценарию:
```sh
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
```

Запустим скрипт и проверим результат вычислений.

*Сценарий, который находит сумму переданных ему чисел*
```
$ ./myscript 5 10
The first parameter is 5.
The second parameter is 10.
The sum is 15.
```

Параметры командной строки не обязательно должны быть числами. Сценариям можно передавать и строки. Например, вот скрипт, работающий со строкой:
```sh
#!/bin/bash
echo Hello $1, how do you do
```

Запустим его:
```
./myscript Adam
```

Он выведет то, что мы от него ожидаем.

*Сценарий, работающий со строковым параметром*
```
$ ./myscript Adam
Hello Adam, how do you do
```

Что если параметр содержит пробелы, а нам надо обрабатывать его как самостоятельный фрагмент данных? Полагаем, если вы освоили предыдущие части этого руководства, ответ вы уже знаете. Заключается он в использовании кавычек.

Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки, например так:
```sh
${10}
```

### Проверка параметров
Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове. Например, это можно организовать так:
```sh
#!/bin/bash
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
```

Вызовем скрипт сначала с параметром, а потом без параметров.

*Вызов скрипта, проверяющего наличие параметров командной строки*
```
$ ./myscript Adam
Hello Adam.
$ ./myscript
No parameters found.
```

### Подсчёт параметров
В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная `$#` содержит количество параметров, переданных сценарию при вызове. 

Опробуем её:
```sh
#!/bin/bash
echo There were $# parameters passed.
```

Вызовем сценарий.
```
./myscript 1 2 3 4 5
```

В результате скрипт сообщит о том, что ему передано 5 параметров.

*Подсчёт количества параметров в скрипте*
```
$ ./myscript 1 2 3 4 5
There were 5 parameters passed.
```

Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не требующий знания их количества. Вот как это выглядит:
```sh
#!/bin/bash
echo The last parameter was ${!#}
```

Вызовем скрипт и посмотрим, что он выведет.

*Обращение к последнему параметру*
```
$ ./myscript 1 2 3 4 5
The last parameter was 5
```

### Захват всех параметров командной строки
В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными `$*` и `$@`. Обе они содержат все параметры командной строки, что делает возможным доступ к тому, что передано сценарию, без использования позиционных параметров.

Переменная `$*` содержит все параметры, введённые в командной строке, в виде единого «слова».

В переменной `$@` параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах. 

Рассмотрим разницу между этими переменными на примерах. Сначала взглянем на их содержимое:
```sh
#!/bin/bash
echo "Using the \$* method: $*"
echo "----------"
echo "Using the \$@ method: $@"
```

Вот вывод скрипта.

*Переменные $* и $@*
```
$ ./myscript 1 2 3 4 5
Using the \$* method: 1 2 3 4 5
----------
Using the \$@ method: 1 2 3 4 5
```

Как видно, при выводе обеих переменных получается одно и то же. Теперь попробуем пройтись по содержимому этих переменных в циклах для того, чтобы увидеть разницу между ними:
```sh
#!/bin/bash
count=1
for param in "$*"
do
echo "\$* Parameter #$count = $param"
count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
echo "\$@ Parameter #$count = $param"
count=$(( $count + 1 ))
done
```

Взгляните на то, что скрипт вывел в консоль. Разница между переменными вполне очевидна.

*Разбор переменных $* и $@ в цикле*
```
$ ./myscript 1 2 3 4 5
$* Parameter #1 = 1 2 3 4 5
$@ Parameter #1 = 1
$@ Parameter #2 = 2
$@ Parameter #3 = 3
$@ Parameter #4 = 4
$@ Parameter #5 = 5
```

Переменная `$*` содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной `$@` они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.

### Команда shift
Использовать команду `shift` в bash-скриптах следует с осторожностью, так как она, в прямом смысле слова, сдвигает значения позиционных параметров.

Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной `$3` становится значением переменной `$2`, значение `$2` переходит в `$1`, а то, что было до этого в `$1`, теряется. Обратите внимание на то, что при этом значение переменной `$0`, содержащей имя скрипта, не меняется.

Воспользовавшись командой `shift`, рассмотрим ещё один способ перебора переданных скрипту параметров:
```sh
#!/bin/bash
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
```

Скрипт задействует цикл `while`, проверяя длину значения первого параметра. Когда длина станет равна нулю, происходит выход из цикла. После проверки первого параметра и вывода его на экран, вызывается команда `shift`, которая сдвигает значения параметров на одну позицию.

*Использование команды `shift` для перебора параметров*
```
$ ./myscript 1 2 3 4 5
$@ Parameter #1 = 1
$@ Parameter #2 = 2
$@ Parameter #3 = 3
$@ Parameter #4 = 4
$@ Parameter #5 = 5
```

Используя команду `shift`, помните о том, что при каждом её вызове значение переменной `$1` безвозвратно теряется.

### Ключи командной строки
Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. Рассмотрим такой пример:
```sh
#!/bin/bash
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
```

Запустим скрипт:
```
./myscript -a -b -c -d
```

И проанализируем то, что он выведет в терминал.

*Обработка ключей в скрипте*
```
$ ./myscript -a -b -c -d

Found the -a option
Found the -b option
Found the -c option
-d is not an option
```

В этом коде использована конструкция `case`, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей. Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта будет использован любой ключ, обработка которого не предусмотрена, будет исполнена ветвь «*».

### Как различать ключи и параметры
Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.

Эта последовательность — двойное тире (`--`). Оболочка использует её для указания позиции, на которой заканчивается список ключей. После того, как скрипт обнаружит признак окончания ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи. Рассмотрим пример:
```sh
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option" ;;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

Этот сценарий использует команду `break` для прерывания цикла while при обнаружении в строке двойного тире. 

Вот что получится после его вызова.

*Обработка ключей и параметров командной строки*
```
$ ./myscript -a -b -c -- 5 10 15
Found the -a option
Found the -b option
Found the -c option
Parameter #1: 5
Parameter #2: 10
Parameter #3: 15
```

Как видно, когда скрипт, разбирая переданные ему данные, находит двойное тире, он завершает обработку ключей и считает всё, что ещё не обработано, параметрами.

### Обработка ключей со значениями
По мере усложнения ваших скриптов, вы столкнётесь с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями. Например, вызов сценария в котором используется подобная возможность, выглядит так:
```
./myscript -a test1 -b -c test2
```

Скрипт должен уметь определять, когда вместе с ключами командной строки используются дополнительные параметры:
```sh
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
-c) echo "Found the -c option";;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in "$@"
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

Вызовем этот скрипт в таком виде:
```
./myscript -a -b test1 -d
```

Посмотрим на результаты его работы.

*Обработка параметров ключей*
```
$ ./myscript -a -b test1 -d
Found the -a option
Found the -b option, with parameter value 15
-d is not an option
```

В данном примере в конструкции `case` обрабатываются три ключа. Ключ `-b` требует наличия дополнительного параметра. Так как обрабатываемый ключ находится в переменной `$1`, соответствующий ему параметр будет находиться в `$2` (тут используется команда `shift`, поэтому, по мере обработки, всё, что передано сценарию, сдвигается влево). Когда с этим мы разобрались, осталось лишь извлечь значение переменной `$2` и у нас будет параметр нужного ключа. Конечно, тут понадобится ещё одна команда `shift` для того, чтобы следующий ключ попал в `$1`.

### Использование стандартных ключей
При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:
- `-a` — Вывести все объекты.
- `-c` — Произвести подсчёт.
- `-d` — Указать директорию.
- `-e` — Развернуть объект.
- `-f` — Указать файл, из которого нужно прочитать данные.
- `-h` — Вывести справку по команде.
- `-i` — Игнорировать регистр символов.
- `-l` — Выполнить полноформатный вывод данных.
- `-n` — Использовать неинтерактивный (пакетный) режим.
- `-o` — Позволяет указать файл, в который нужно перенаправить вывод.
- `-q` — Выполнить скрипт в quiet-режиме.
- `-r` — Обрабатывать папки и файлы рекурсивно.
- `-s` — Выполнить скрипт в silent-режиме.
- `-v` — Выполнить многословный вывод.
- `-x` — Исключить объект.
- `-y` — Ответить «yes» на все вопросы.

Если вы работаете в Linux, вам, скорее всего, знакомы многие из этих ключей. Использовав их в общепринятом значении в своих скриптах, вы поможете пользователям взаимодействовать с ними, не беспокоясь о чтении документации.

### Получение данных от пользователя
Ключи и параметры командной строки — это отличный способ получить данные от того, кто пользуется скриптом, однако в некоторых случаях нужно больше интерактивности.

Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда `read`.

Эта команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов. После получения данных, эта команда помещает их в переменную:
```sh
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
```

Обратите внимание на то, что команда `echo`, которая выводит приглашение, вызывается с ключом `-n`. Это приводит к тому, что в конце приглашения не выводится знак перевода строки, что позволяет пользователю скрипта вводить данные там же, где расположено приглашение, а не на следующей строке.

*Обработка пользовательского ввода*
```
$ ./myscript
Enter your name: Adam
Hello Adam, welcome to my program.
```

При вызове `read` можно указывать и несколько переменных:
```sh
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first..."
```

Вот что выведет скрипт после запуска.

*Несколько переменных в команде read*
```
$ ./myscript
Enter your name: first last
Your data for last, first...
```

Если, вызвав `read`, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY:`
```sh
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
```

*Использование переменной среды REPLY*
```
$ ./myscript
Enter your name: Adam
Hello Adam, welcome to my program.
```

Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду `read` можно воспользоваться ключом `-t`. А именно, параметр ключа задаёт время ожидания ввода в секундах:
```sh
#/bin/bash
if read -t 5 -p "Enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo "Sorry, too slow! "
fi
```

Если данные не будут введены в течение 5 секунд, скрипт выполнит ветвь условного оператора `else`, выведя извинения.

*Ограничение времени на ввод данных*
```
$ ./myscript
Enter your name: Sorry, too slow!
```

### Ввод паролей
Иногда то, что вводит пользователь в ответ на вопрос скрипта, лучше на экране не показывать. Например, так обычно делают, запрашивая пароли. Ключ `-s` команды `read` предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда `read` делает цвет текста таким же, как цвет фона.

```sh
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
```

Вот как отработает этот скрипт.

*Ввод конфиденциальных данных*
```
$ ./myscript
Enter your password: Is your password really secretpass?
```

### Чтение данных из файла
Команда `read` может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится. Если нужно получить в скрипте всё содержимое файла, можно, с помощью конвейера, передать результаты вызова команды `cat` для файла, конструкции `while`, которая содержит команду `read` (конечно, использование команды `cat` выглядит примитивно, но наша цель — показать всё максимально просто, ориентируясь на новичков; опытные пользователи, уверены, это поймут).

Напишем скрипт, в котором используется только что описанный подход к чтению файлов.

```sh
#!/bin/bash
count=1
cat myfile | while read line
do
echo "Line $count: $line"
count=$(( $count + 1 ))
done
echo "Finished"
```

Посмотрим на него в деле.

*Чтение данных из файла*
```
$ ./myscript
Line 1: hello
Line 2: this
Line 3: is
Line 4: test
Finished
```

Тут мы передали в цикл `while` содержимое файла и перебрали все строки этого файла, выводя номер и содержимое каждой из них.

### Итоги
Сегодня мы разобрали работу с ключами и параметрами командной строки. Без этих средств диапазон использования скриптов оказывается чрезвычайно узким. Даже если скрипт написан, что называется, «для себя». Тут же мы рассмотрели подходы к получению данных от пользователя во время выполнения программы — это делает сценарии интерактивными.

В следующий раз поговорим об операциях ввода и вывода.

Уважаемые читатели! Спасибо вам за то, что делитесь опытом в комментариях к предыдущим частям этого цикла материалов. Если вам есть что сказать об обработке всего того, что можно передать в скрипт при запуске или во время его работы, уверены, многим будет интересно об этом почитать.

## Функции
[67a363d75040133e8429edf7](https://e-learn.petrocollege.ru/course/view.php?id=6815#section-3)

Занимаясь разработкой bash-скриптов, вы рано или поздно столкнётесь с тем, что вам периодически приходится использовать одни и те же фрагменты кода. Постоянно набирать их вручную скучно, а копирование и вставка — не наш метод. Как быть? Хорошо бы найти средство, которое позволяет один раз написать блок кода и, когда он понадобится снова, просто сослаться на него в скрипте.

Оболочка bash предоставляет такую возможность, позволяя создавать функции. Функции bash — это именованные блоки кода, которые можно повторно использовать в скриптах.
Структура объявления функций:

- `functionName { }` – функция без параметров;
- `functionName() { }` – функция с параметрами.

Напишем с вами скрипт, содержащий объявление функции и использующий её:
```sh
#!/bin/bash
function myfunc {
  echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "This is the end of the loop"
myfunc
echo "End of the script"
```

```
./myscript.sh
This is an example of using a function
This is an example of using a function
This is an example of using a function
This is the end of the loop
This is an example of using a function
End of the script
```

### Использование команды return
Команды **`return`** позволяет задавать возвращаемый функцией целочисленный код завершения. Есть два способа работы с тем, что является результатом вызова функции.

Первый способ:
```sh
#!/bin/bash
function myfunc {
  read -p "Enter a value: " value
  echo "adding value"
  return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"
```

```
$
Enter a value: 10
The value is 20
```

Второй способ заключается в записи данных, выводимых функцией, в переменную. Рассмотрим пример:
```sh
#!/bin/bash
function myfunc {
  read -p "Enter a value: " value
  echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
```

```
$
Enter a value: 10
The value is 20
```

### Аргументы функций
Функции могут использовать стандартные позиционные параметры, в которые записывается то, что передаётся им при вызове. Например, имя функции хранится в параметре `$0`, первый переданный ей аргумент — в `$1`, второй — в `$2`, и так далее.

Количество переданных функции аргументов можно узнать, обратившись к переменной `$#`.

Аргументы передают функции, записывая их после её имени:
```sh
myfunc $val1 10 20
```

### Глобальные переменные
Глобальные переменные — это переменные, которые видны из любого места bash-скрипта. Если вы объявили глобальную переменную в основном коде скрипта, к такой переменной можно обратиться из функции.

Почти то же самое справедливо и для глобальных переменных, объявленных в функциях. Обращаться к ним можно и в основном коде скрипта после вызова функций.

```sh
#!/bin/bash
function myfunc {
  value=$(( $value + 10 ))
}
read -p "Enter a value: " value
myfunc
echo "The new value is: $value"
```

### Локальные переменные
Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными. Для того, чтобы это сделать, используется ключевое слово `local` перед именем переменной:
```sh
local temp=$(( $temp + 5 ))
```

Если за пределами функции есть переменная с таким же именем, это на неё не повлияет. Ключевое слово `local` позволяет отделить переменные, используемые внутри функции, от остальных переменных.

```sh
#!/bin/bash
function myfunc {
  local temp=$[ $temp + 5 ]
  echo "The Temp from inside function is $temp"
}
temp=4
myfunc
echo "The temp from outside is $temp"
```

### Bash-скрипты: Регулярные выражения
Регулярные выражения — это очень мощный инструмент для поиска текста по шаблону, обработки и изменения строк, который можно применять для решения множества задач.

Вот основные из них:
- Проверка ввода текста;
- Поиск и замена текста в файле;
- Пакетное переименование файлов;
- Проверка строки на соответствие шаблону.

Регулярные выражения — это очень мощный инструмент для поиска. В регулярных выражениях могут использоваться два типа символов:
- Обычные буквы;
- Метасимволы.

*Обычные символы* — это буквы, цифры и знаки препинания, из которых состоят любые строки. Все тексты состоят из букв и вы можете использовать их в регулярных выражениях для поиска нужной позиции в тексте.

*Метасимволы* — это кое-что другое, именно они дают силу регулярным выражениям. С помощью метасимволов вы можете сделать намного больше чем поиск одного символа. Вы можете искать комбинации символов, использовать динамическое их количество и выбирать диапазоны.

Все спецсимволы можно разделить на два типа, это символы замены, которые заменяют собой обычные символы, или операторы, которые указывают сколько раз может повторяться символ. Синтаксис регулярного выражения будет выглядеть таким образом:
```
обычный_символ спецсимвол_оператор
спецсимвол_замены спецсимвол_оператор
```

- `\` — с обратной косой черты начиаются буквенные спецсимволы, а также они используются, если нужно использовать спецсимвол в виде какого-либо знака препинания;
- `^` — указывает на начало строки;
- `$` — указывает на конец строки;
- `*` — указывает, что предыдущий символ может повторяться 0 или больше раз;
- `+` — указывает, что предыдущий символ должен повторится один или больше раз;
- `?` — предыдущий символ может встречаться ноль или один раз;
- `{n}` — указывает сколько раз (`n`) нужно повторить предыдущий символ;
- `{N,n}` — предыдущий символ может повторяться от `N` до `n` раз;
- `.` — любой символ кроме перевода строки;
- `[az]` — любой символ, указанный в скобках;
- `х|у` — символ `x` или символ `y`;
- `[^az]` — любой символ, кроме тех, что указаны в скобках;
- `[a-z]` — любой символ из указанного диапазона;
- `[^a-z]` — любой символ, которого нет в диапазоне;
- `\b` — обозначает границу слова с пробелом;
- `\B` — обозначает что символ должен быть внутри слова, например, `ux` совпадет с `uxb` или `tuxedo`, но не совпадет с `Linux`;
- `\d` — означает, что символ — цифра;
- `\D` — нецифровой символ;
- `\n` — символ перевода строки;
- `\s` — один из пробельных (whitespace) символов — пробел, табуляция и так далее;
- `\S` — любой символ кроме пробела;
- `\t` — символ табуляции;
- `\v` — символ вертикальной табуляции;
- `\w` — любой буквенный символ, включая подчеркивание;
- `\W` — любой буквенный символ, кроме подчеркивания;
- `\uXXX `– символ Unicode.

Важно отметить, что перед буквенными спецсимволами нужно использовать косую черту, чтобы указать, что дальше идет спецсимвол. Правильно и обратное, если вы хотите использовать спецсимвол, который применяется без косой черты в качестве обычного символа, то вам придется добавить косую черту.

Например, вы хотите найти в тексте строку `1+ 2=3`. Если вы используете эту строку в качестве регулярного выражения, то ничего не найдете, потому что система интерпретирует плюс как спецсимвол, который сообщает, что предыдущая единица должна повториться один или больше раз. Поэтому его нужно экранировать: `1 \+ 2 = 3`. Без экранирования наше регулярное выражение соответствовало бы только строке `11=3` или `111=3` и так далее. Перед равно черту ставить не нужно, потому что это не спецсимвол.[^regulyarnye-vyrazheniya-linux]

[^regulyarnye-vyrazheniya-linux]: [РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ LINUX](https://bafista.ru/regulyarnye-vyrazheniya-linux/)

## Самостоятельные работы
[67a3d7615040133e8429ee08](https://e-learn.petrocollege.ru/course/view.php?id=6815#section-4)
